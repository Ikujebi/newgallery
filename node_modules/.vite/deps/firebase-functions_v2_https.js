import {
  require_auth,
  require_crypto_signer,
  require_jwt
} from "./chunk-EFPXU4ZM.js";
import {
  require_api_request,
  require_app,
  require_error,
  require_fs,
  require_path,
  require_util,
  require_utils,
  require_validator
} from "./chunk-XWM4Y27S.js";
import {
  __commonJS
} from "./chunk-ROME4SDB.js";

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/vary/index.js
var require_vary = __commonJS({
  "node_modules/vary/index.js"(exports, module) {
    "use strict";
    module.exports = vary;
    module.exports.append = append;
    var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    function append(header, field) {
      if (typeof header !== "string") {
        throw new TypeError("header argument is required");
      }
      if (!field) {
        throw new TypeError("field argument is required");
      }
      var fields = !Array.isArray(field) ? parse(String(field)) : field;
      for (var j = 0; j < fields.length; j++) {
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
          throw new TypeError("field argument contains an invalid header name");
        }
      }
      if (header === "*") {
        return header;
      }
      var val = header;
      var vals = parse(header.toLowerCase());
      if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
      }
      for (var i = 0; i < fields.length; i++) {
        var fld = fields[i].toLowerCase();
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val ? val + ", " + fields[i] : fields[i];
        }
      }
      return val;
    }
    function parse(header) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = header.length; i < len; i++) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(header.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(header.substring(start, end));
      return list;
    }
    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        throw new TypeError("res argument is required");
      }
      var val = res.getHeader("Vary") || "";
      var header = Array.isArray(val) ? val.join(", ") : String(val);
      if (val = append(header, field)) {
        res.setHeader("Vary", val);
      }
    }
  }
});

// node_modules/cors/lib/index.js
var require_lib = __commonJS({
  "node_modules/cors/lib/index.js"(exports, module) {
    (function() {
      "use strict";
      var assign = require_object_assign();
      var vary = require_vary();
      var defaults = {
        origin: "*",
        methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
        preflightContinue: false,
        optionsSuccessStatus: 204
      };
      function isString(s) {
        return typeof s === "string" || s instanceof String;
      }
      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i = 0; i < allowedOrigin.length; ++i) {
            if (isOriginAllowed(origin, allowedOrigin[i])) {
              return true;
            }
          }
          return false;
        } else if (isString(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }
      function configureOrigin(options, req) {
        var requestOrigin = req.headers.origin, headers = [], isAllowed;
        if (!options.origin || options.origin === "*") {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: "*"
          }]);
        } else if (isString(options.origin)) {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: options.origin
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options.origin);
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: isAllowed ? requestOrigin : false
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        }
        return headers;
      }
      function configureMethods(options) {
        var methods = options.methods;
        if (methods.join) {
          methods = options.methods.join(",");
        }
        return {
          key: "Access-Control-Allow-Methods",
          value: methods
        };
      }
      function configureCredentials(options) {
        if (options.credentials === true) {
          return {
            key: "Access-Control-Allow-Credentials",
            value: "true"
          };
        }
        return null;
      }
      function configureAllowedHeaders(options, req) {
        var allowedHeaders = options.allowedHeaders || options.headers;
        var headers = [];
        if (!allowedHeaders) {
          allowedHeaders = req.headers["access-control-request-headers"];
          headers.push([{
            key: "Vary",
            value: "Access-Control-Request-Headers"
          }]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(",");
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([{
            key: "Access-Control-Allow-Headers",
            value: allowedHeaders
          }]);
        }
        return headers;
      }
      function configureExposedHeaders(options) {
        var headers = options.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(",");
        }
        if (headers && headers.length) {
          return {
            key: "Access-Control-Expose-Headers",
            value: headers
          };
        }
        return null;
      }
      function configureMaxAge(options) {
        var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: "Access-Control-Max-Age",
            value: maxAge
          };
        }
        return null;
      }
      function applyHeaders(headers, res) {
        for (var i = 0, n = headers.length; i < n; i++) {
          var header = headers[i];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === "Vary" && header.value) {
              vary(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }
      function cors(options, req, res, next) {
        var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
        if (method === "OPTIONS") {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureMethods(options, req));
          headers.push(configureAllowedHeaders(options, req));
          headers.push(configureMaxAge(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          if (options.preflightContinue) {
            next();
          } else {
            res.statusCode = options.optionsSuccessStatus;
            res.setHeader("Content-Length", "0");
            res.end();
          }
        } else {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          next();
        }
      }
      function middlewareWrapper(o) {
        var optionsCallback = null;
        if (typeof o === "function") {
          optionsCallback = o;
        } else {
          optionsCallback = function(req, cb) {
            cb(null, o);
          };
        }
        return function corsMiddleware(req, res, next) {
          optionsCallback(req, function(err, options) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults, options);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === "function") {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function(origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }
              if (originCallback) {
                originCallback(req.headers.origin, function(err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors(corsOptions, req, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }
      module.exports = middlewareWrapper;
    })();
  }
});

// browser-external:async_hooks
var require_async_hooks = __commonJS({
  "browser-external:async_hooks"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "async_hooks" has been externalized for browser compatibility. Cannot access "async_hooks.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/firebase-functions/lib/common/trace.js
var require_trace = __commonJS({
  "node_modules/firebase-functions/lib/common/trace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractTraceContext = exports.traceContext = void 0;
    var async_hooks_1 = require_async_hooks();
    exports.traceContext = new async_hooks_1.AsyncLocalStorage();
    var CLOUD_TRACE_REGEX = new RegExp("^(?<traceId>[A-Fa-f0-9]{32})/(?<parentIdInt>[0-9]+)(?:;o=(?<traceMask>[0-3]))?$");
    var CLOUD_TRACE_HEADER = "X-Cloud-Trace-Context";
    function matchCloudTraceHeader(carrier) {
      let header = carrier === null || carrier === void 0 ? void 0 : carrier[CLOUD_TRACE_HEADER];
      if (!header) {
        header = carrier === null || carrier === void 0 ? void 0 : carrier[CLOUD_TRACE_HEADER.toLowerCase()];
      }
      if (header && typeof header === "string") {
        const matches = CLOUD_TRACE_REGEX.exec(header);
        if (matches && matches.groups) {
          const { traceId, parentIdInt, traceMask } = matches.groups;
          const parentId = parseInt(parentIdInt);
          if (isNaN(parentId)) {
            return;
          }
          const sample = !!traceMask && traceMask !== "0";
          return { traceId, parentId: parentId.toString(16), sample, version: "00" };
        }
      }
    }
    var TRACEPARENT_REGEX = new RegExp("^(?<version>[a-f0-9]{2})-(?<traceId>[a-f0-9]{32})-(?<parentId>[a-f0-9]{16})-(?<flag>[a-f0-9]{2})$");
    var TRACEPARENT_HEADER = "traceparent";
    function matchTraceparentHeader(carrier) {
      const header = carrier === null || carrier === void 0 ? void 0 : carrier[TRACEPARENT_HEADER];
      if (header && typeof header === "string") {
        const matches = TRACEPARENT_REGEX.exec(header);
        if (matches && matches.groups) {
          const { version, traceId, parentId, flag } = matches.groups;
          const sample = flag === "01";
          return { traceId, parentId, sample, version };
        }
      }
    }
    function extractTraceContext(carrier) {
      return matchCloudTraceHeader(carrier) || matchTraceparentHeader(carrier);
    }
    exports.extractTraceContext = extractTraceContext;
  }
});

// node_modules/firebase-functions/lib/logger/common.js
var require_common = __commonJS({
  "node_modules/firebase-functions/lib/logger/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UNPATCHED_CONSOLE = exports.CONSOLE_SEVERITY = void 0;
    exports.CONSOLE_SEVERITY = {
      DEBUG: "debug",
      INFO: "info",
      NOTICE: "info",
      WARNING: "warn",
      ERROR: "error",
      CRITICAL: "error",
      ALERT: "error",
      EMERGENCY: "error"
    };
    exports.UNPATCHED_CONSOLE = {
      debug: console.debug,
      info: console.info,
      log: console.log,
      warn: console.warn,
      error: console.error
    };
  }
});

// node_modules/firebase-functions/lib/logger/index.js
var require_logger = __commonJS({
  "node_modules/firebase-functions/lib/logger/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.error = exports.warn = exports.info = exports.log = exports.debug = exports.write = void 0;
    var util_1 = require_util();
    var trace_1 = require_trace();
    var common_1 = require_common();
    function removeCircular(obj, refs = []) {
      if (typeof obj !== "object" || !obj) {
        return obj;
      }
      if (obj.toJSON) {
        return obj.toJSON();
      }
      if (refs.includes(obj)) {
        return "[Circular]";
      } else {
        refs.push(obj);
      }
      let returnObj;
      if (Array.isArray(obj)) {
        returnObj = new Array(obj.length);
      } else {
        returnObj = {};
      }
      for (const k in obj) {
        if (refs.includes(obj[k])) {
          returnObj[k] = "[Circular]";
        } else {
          returnObj[k] = removeCircular(obj[k], refs);
        }
      }
      return returnObj;
    }
    function write(entry) {
      common_1.UNPATCHED_CONSOLE[common_1.CONSOLE_SEVERITY[entry.severity]](JSON.stringify(removeCircular(entry)));
    }
    exports.write = write;
    function debug(...args) {
      write(entryFromArgs("DEBUG", args));
    }
    exports.debug = debug;
    function log(...args) {
      write(entryFromArgs("INFO", args));
    }
    exports.log = log;
    function info(...args) {
      write(entryFromArgs("INFO", args));
    }
    exports.info = info;
    function warn(...args) {
      write(entryFromArgs("WARNING", args));
    }
    exports.warn = warn;
    function error(...args) {
      write(entryFromArgs("ERROR", args));
    }
    exports.error = error;
    function entryFromArgs(severity, args) {
      let entry = {};
      const lastArg = args[args.length - 1];
      if (lastArg && typeof lastArg === "object" && lastArg.constructor === Object) {
        entry = args.pop();
      }
      const ctx = trace_1.traceContext.getStore();
      let message = (0, util_1.format)(...args);
      if (severity === "ERROR" && !args.find((arg) => arg instanceof Error)) {
        message = new Error(message).stack || message;
      }
      const out = {
        "logging.googleapis.com/trace": (ctx === null || ctx === void 0 ? void 0 : ctx.traceId) ? `projects/${process.env.GCLOUD_PROJECT}/traces/${ctx.traceId}` : void 0,
        ...entry,
        severity
      };
      if (message) {
        out.message = message;
      }
      return out;
    }
  }
});

// node_modules/firebase-functions/lib/params/types.js
var require_types = __commonJS({
  "node_modules/firebase-functions/lib/params/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListParam = exports.BooleanParam = exports.FloatParam = exports.IntParam = exports.InternalExpression = exports.StringParam = exports.SecretParam = exports.Param = exports.CompareExpression = exports.TernaryExpression = exports.Expression = void 0;
    var logger = require_logger();
    var Expression = class {
      /** Returns the Expression's runtime value, based on the CLI's resolution of params. */
      value() {
        if (process.env.FUNCTIONS_CONTROL_API === "true") {
          logger.warn(`${this.toString()}.value() invoked during function deployment, instead of during runtime.`);
          logger.warn(`This is usually a mistake. In configs, use Params directly without calling .value().`);
          logger.warn(`example: { memory: memoryParam } not { memory: memoryParam.value() }`);
        }
        return this.runtimeValue();
      }
      /** @internal */
      runtimeValue() {
        throw new Error("Not implemented");
      }
      /** Returns the Expression's representation as a braced CEL expression. */
      toCEL() {
        return `{{ ${this.toString()} }}`;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports.Expression = Expression;
    function valueOf(arg) {
      return arg instanceof Expression ? arg.runtimeValue() : arg;
    }
    function refOf(arg) {
      if (arg instanceof Expression) {
        return arg.toString();
      } else if (typeof arg === "string") {
        return `"${arg}"`;
      } else if (Array.isArray(arg)) {
        return JSON.stringify(arg);
      } else {
        return arg.toString();
      }
    }
    var TernaryExpression = class extends Expression {
      constructor(test, ifTrue, ifFalse) {
        super();
        this.test = test;
        this.ifTrue = ifTrue;
        this.ifFalse = ifFalse;
        this.ifTrue = ifTrue;
        this.ifFalse = ifFalse;
      }
      /** @internal */
      runtimeValue() {
        return this.test.runtimeValue() ? valueOf(this.ifTrue) : valueOf(this.ifFalse);
      }
      toString() {
        return `${this.test} ? ${refOf(this.ifTrue)} : ${refOf(this.ifFalse)}`;
      }
    };
    exports.TernaryExpression = TernaryExpression;
    var CompareExpression = class extends Expression {
      constructor(cmp, lhs, rhs) {
        super();
        this.cmp = cmp;
        this.lhs = lhs;
        this.rhs = rhs;
      }
      /** @internal */
      runtimeValue() {
        const left = this.lhs.runtimeValue();
        const right = valueOf(this.rhs);
        switch (this.cmp) {
          case "==":
            return Array.isArray(left) ? this.arrayEquals(left, right) : left === right;
          case "!=":
            return Array.isArray(left) ? !this.arrayEquals(left, right) : left !== right;
          case ">":
            return left > right;
          case ">=":
            return left >= right;
          case "<":
            return left < right;
          case "<=":
            return left <= right;
          default:
            throw new Error(`Unknown comparator ${this.cmp}`);
        }
      }
      /** @internal */
      arrayEquals(a, b) {
        return a.every((item) => b.includes(item)) && b.every((item) => a.includes(item));
      }
      toString() {
        const rhsStr = refOf(this.rhs);
        return `${this.lhs} ${this.cmp} ${rhsStr}`;
      }
      /** Returns a TernaryExpression which can resolve to one of two values, based on the resolution of this comparison. */
      thenElse(ifTrue, ifFalse) {
        return new TernaryExpression(this, ifTrue, ifFalse);
      }
    };
    exports.CompareExpression = CompareExpression;
    var Param = class extends Expression {
      constructor(name, options = {}) {
        super();
        this.name = name;
        this.options = options;
      }
      /** @internal */
      runtimeValue() {
        throw new Error("Not implemented");
      }
      /** Returns a parametrized expression of Boolean type, based on comparing the value of this param to a literal or a different expression. */
      cmp(cmp, rhs) {
        return new CompareExpression(cmp, this, rhs);
      }
      /** Returns a parametrized expression of Boolean type, based on comparing the value of this param to a literal or a different expression. */
      equals(rhs) {
        return this.cmp("==", rhs);
      }
      /** Returns a parametrized expression of Boolean type, based on comparing the value of this param to a literal or a different expression. */
      notEquals(rhs) {
        return this.cmp("!=", rhs);
      }
      /** Returns a parametrized expression of Boolean type, based on comparing the value of this param to a literal or a different expression. */
      greaterThan(rhs) {
        return this.cmp(">", rhs);
      }
      /** Returns a parametrized expression of Boolean type, based on comparing the value of this param to a literal or a different expression. */
      greaterThanOrEqualTo(rhs) {
        return this.cmp(">=", rhs);
      }
      /** Returns a parametrized expression of Boolean type, based on comparing the value of this param to a literal or a different expression. */
      lessThan(rhs) {
        return this.cmp("<", rhs);
      }
      /** Returns a parametrized expression of Boolean type, based on comparing the value of this param to a literal or a different expression. */
      lessThanOrEqualTo(rhs) {
        return this.cmp("<=", rhs);
      }
      /**
       * Returns a parametrized expression of Boolean type, based on comparing the value of this param to a literal or a different expression.
       * @deprecated A typo. Use lessThanOrEqualTo instead.
       */
      lessThanorEqualTo(rhs) {
        return this.lessThanOrEqualTo(rhs);
      }
      toString() {
        return `params.${this.name}`;
      }
      /** @internal */
      toSpec() {
        const { default: paramDefault, ...otherOptions } = this.options;
        const out = {
          name: this.name,
          ...otherOptions,
          type: this.constructor.type
        };
        if (paramDefault instanceof Expression) {
          out.default = paramDefault.toCEL();
        } else if (paramDefault !== void 0) {
          out.default = paramDefault;
        }
        if (out.input && "text" in out.input && out.input.text.validationRegex instanceof RegExp) {
          out.input.text.validationRegex = out.input.text.validationRegex.source;
        }
        return out;
      }
    };
    exports.Param = Param;
    Param.type = "string";
    var SecretParam = class {
      constructor(name) {
        this.name = name;
      }
      /** @internal */
      runtimeValue() {
        const val = process.env[this.name];
        if (val === void 0) {
          logger.warn(`No value found for secret parameter "${this.name}". A function can only access a secret if you include the secret in the function's dependency array.`);
        }
        return val || "";
      }
      /** @internal */
      toSpec() {
        return {
          type: "secret",
          name: this.name
        };
      }
      /** Returns the secret's value at runtime. Throws an error if accessed during deployment. */
      value() {
        if (process.env.FUNCTIONS_CONTROL_API === "true") {
          throw new Error(`Cannot access the value of secret "${this.name}" during function deployment. Secret values are only available at runtime.`);
        }
        return this.runtimeValue();
      }
    };
    exports.SecretParam = SecretParam;
    SecretParam.type = "secret";
    var StringParam = class extends Param {
      /** @internal */
      runtimeValue() {
        return process.env[this.name] || "";
      }
    };
    exports.StringParam = StringParam;
    var InternalExpression = class extends Param {
      constructor(name, getter) {
        super(name);
        this.getter = getter;
      }
      /** @internal */
      runtimeValue() {
        return this.getter(process.env) || "";
      }
      toSpec() {
        throw new Error("An InternalExpression should never be marshalled for wire transmission.");
      }
    };
    exports.InternalExpression = InternalExpression;
    var IntParam = class extends Param {
      /** @internal */
      runtimeValue() {
        return parseInt(process.env[this.name] || "0", 10) || 0;
      }
    };
    exports.IntParam = IntParam;
    IntParam.type = "int";
    var FloatParam = class extends Param {
      /** @internal */
      runtimeValue() {
        return parseFloat(process.env[this.name] || "0") || 0;
      }
    };
    exports.FloatParam = FloatParam;
    FloatParam.type = "float";
    var BooleanParam = class extends Param {
      /** @internal */
      runtimeValue() {
        return !!process.env[this.name] && process.env[this.name] === "true";
      }
      /** @deprecated */
      then(ifTrue, ifFalse) {
        return this.thenElse(ifTrue, ifFalse);
      }
      thenElse(ifTrue, ifFalse) {
        return new TernaryExpression(this, ifTrue, ifFalse);
      }
    };
    exports.BooleanParam = BooleanParam;
    BooleanParam.type = "boolean";
    var ListParam = class extends Param {
      /** @internal */
      runtimeValue() {
        const val = JSON.parse(process.env[this.name]);
        if (!Array.isArray(val) || !val.every((v) => typeof v === "string")) {
          return [];
        }
        return val;
      }
      /** @hidden */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      greaterThan(rhs) {
        throw new Error(">/< comparison operators not supported on params of type List");
      }
      /** @hidden */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      greaterThanOrEqualTo(rhs) {
        throw new Error(">/< comparison operators not supported on params of type List");
      }
      /** @hidden */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      lessThan(rhs) {
        throw new Error(">/< comparison operators not supported on params of type List");
      }
      /** @hidden */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      lessThanorEqualTo(rhs) {
        throw new Error(">/< comparison operators not supported on params of type List");
      }
    };
    exports.ListParam = ListParam;
    ListParam.type = "list";
  }
});

// node_modules/firebase-functions/lib/params/index.js
var require_params = __commonJS({
  "node_modules/firebase-functions/lib/params/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineList = exports.defineFloat = exports.defineInt = exports.defineBoolean = exports.defineString = exports.defineSecret = exports.storageBucket = exports.gcloudProject = exports.projectID = exports.databaseURL = exports.clearParams = exports.declaredParams = exports.Expression = void 0;
    var types_1 = require_types();
    Object.defineProperty(exports, "Expression", { enumerable: true, get: function() {
      return types_1.Expression;
    } });
    exports.declaredParams = [];
    function registerParam(param) {
      for (let i = 0; i < exports.declaredParams.length; i++) {
        if (exports.declaredParams[i].name === param.name) {
          exports.declaredParams.splice(i, 1);
        }
      }
      exports.declaredParams.push(param);
    }
    function clearParams() {
      exports.declaredParams.splice(0, exports.declaredParams.length);
    }
    exports.clearParams = clearParams;
    exports.databaseURL = new types_1.InternalExpression("DATABASE_URL", (env) => {
      var _a;
      return ((_a = JSON.parse(env.FIREBASE_CONFIG)) === null || _a === void 0 ? void 0 : _a.databaseURL) || "";
    });
    exports.projectID = new types_1.InternalExpression("PROJECT_ID", (env) => {
      var _a;
      return ((_a = JSON.parse(env.FIREBASE_CONFIG)) === null || _a === void 0 ? void 0 : _a.projectId) || "";
    });
    exports.gcloudProject = new types_1.InternalExpression("GCLOUD_PROJECT", (env) => {
      var _a;
      return ((_a = JSON.parse(env.FIREBASE_CONFIG)) === null || _a === void 0 ? void 0 : _a.projectId) || "";
    });
    exports.storageBucket = new types_1.InternalExpression("STORAGE_BUCKET", (env) => {
      var _a;
      return ((_a = JSON.parse(env.FIREBASE_CONFIG)) === null || _a === void 0 ? void 0 : _a.storageBucket) || "";
    });
    function defineSecret(name) {
      const param = new types_1.SecretParam(name);
      registerParam(param);
      return param;
    }
    exports.defineSecret = defineSecret;
    function defineString(name, options = {}) {
      const param = new types_1.StringParam(name, options);
      registerParam(param);
      return param;
    }
    exports.defineString = defineString;
    function defineBoolean(name, options = {}) {
      const param = new types_1.BooleanParam(name, options);
      registerParam(param);
      return param;
    }
    exports.defineBoolean = defineBoolean;
    function defineInt(name, options = {}) {
      const param = new types_1.IntParam(name, options);
      registerParam(param);
      return param;
    }
    exports.defineInt = defineInt;
    function defineFloat(name, options = {}) {
      const param = new types_1.FloatParam(name, options);
      registerParam(param);
      return param;
    }
    exports.defineFloat = defineFloat;
    function defineList(name, options = {}) {
      const param = new types_1.ListParam(name, options);
      registerParam(param);
      return param;
    }
    exports.defineList = defineList;
  }
});

// node_modules/firebase-functions/lib/common/encoding.js
var require_encoding = __commonJS({
  "node_modules/firebase-functions/lib/common/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertInvoker = exports.serviceAccountFromShorthand = exports.convertIfPresent = exports.copyIfPresent = exports.durationFromSeconds = void 0;
    var params_1 = require_params();
    function durationFromSeconds(s) {
      return `${s}s`;
    }
    exports.durationFromSeconds = durationFromSeconds;
    function copyIfPresent(dest, src, ...fields) {
      if (!src) {
        return;
      }
      for (const field of fields) {
        if (!Object.prototype.hasOwnProperty.call(src, field)) {
          continue;
        }
        dest[field] = src[field];
      }
    }
    exports.copyIfPresent = copyIfPresent;
    function convertIfPresent(dest, src, destField, srcField, converter = (from) => {
      return from;
    }) {
      if (!src) {
        return;
      }
      if (!Object.prototype.hasOwnProperty.call(src, srcField)) {
        return;
      }
      dest[destField] = converter(src[srcField]);
    }
    exports.convertIfPresent = convertIfPresent;
    function serviceAccountFromShorthand(serviceAccount) {
      if (serviceAccount === "default") {
        return null;
      } else if (serviceAccount instanceof params_1.Expression) {
        return serviceAccount;
      } else if (serviceAccount.endsWith("@")) {
        if (!process.env.GCLOUD_PROJECT) {
          throw new Error(`Unable to determine email for service account '${serviceAccount}' because process.env.GCLOUD_PROJECT is not set.`);
        }
        return `${serviceAccount}${process.env.GCLOUD_PROJECT}.iam.gserviceaccount.com`;
      } else if (serviceAccount.includes("@")) {
        return serviceAccount;
      } else {
        throw new Error(`Invalid option for serviceAccount: '${serviceAccount}'. Valid options are 'default', a service account email, or '{serviceAccountName}@'`);
      }
    }
    exports.serviceAccountFromShorthand = serviceAccountFromShorthand;
    function convertInvoker(invoker) {
      if (typeof invoker === "string") {
        invoker = [invoker];
      }
      if (invoker.length === 0) {
        throw new Error("Invalid option for invoker: Must be a non-empty array.");
      }
      if (invoker.find((inv) => inv.length === 0)) {
        throw new Error("Invalid option for invoker: Must be a non-empty string.");
      }
      if (invoker.length > 1 && invoker.find((inv) => inv === "public" || inv === "private")) {
        throw new Error("Invalid option for invoker: Cannot have 'public' or 'private' in an array of service accounts.");
      }
      return invoker;
    }
    exports.convertInvoker = convertInvoker;
  }
});

// node_modules/firebase-functions/lib/v2/trace.js
var require_trace2 = __commonJS({
  "node_modules/firebase-functions/lib/v2/trace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapTraceContext = void 0;
    var trace_1 = require_trace();
    function wrapTraceContext(handler) {
      return (...args) => {
        let traceParent;
        if (args.length === 1) {
          traceParent = (0, trace_1.extractTraceContext)(args[0]);
        } else {
          traceParent = (0, trace_1.extractTraceContext)(args[0].headers);
        }
        if (!traceParent) {
          return handler.apply(null, args);
        }
        return trace_1.traceContext.run(traceParent, handler, ...args);
      };
    }
    exports.wrapTraceContext = wrapTraceContext;
  }
});

// node_modules/firebase-functions/lib/common/debug.js
var require_debug = __commonJS({
  "node_modules/firebase-functions/lib/common/debug.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDebugFeatureEnabled = exports.debugFeatureValue = void 0;
    var debugMode = process.env.FIREBASE_DEBUG_MODE === "true";
    function loadDebugFeatures() {
      if (!debugMode) {
        return {};
      }
      try {
        const obj = JSON.parse(process.env.FIREBASE_DEBUG_FEATURES);
        if (typeof obj !== "object") {
          return {};
        }
        return obj;
      } catch (e) {
        return {};
      }
    }
    function debugFeatureValue(feat) {
      if (!debugMode) {
        return;
      }
      return loadDebugFeatures()[feat];
    }
    exports.debugFeatureValue = debugFeatureValue;
    function isDebugFeatureEnabled(feat) {
      return debugMode && !!debugFeatureValue(feat);
    }
    exports.isDebugFeatureEnabled = isDebugFeatureEnabled;
  }
});

// node_modules/firebase-admin/lib/app-check/app-check-api-client-internal.js
var require_app_check_api_client_internal = __commonJS({
  "node_modules/firebase-admin/lib/app-check/app-check-api-client-internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FirebaseAppCheckError = exports.APP_CHECK_ERROR_CODE_MAPPING = exports.AppCheckApiClient = void 0;
    var api_request_1 = require_api_request();
    var error_1 = require_error();
    var utils = require_utils();
    var validator = require_validator();
    var FIREBASE_APP_CHECK_V1_API_URL_FORMAT = "https://firebaseappcheck.googleapis.com/v1/projects/{projectId}/apps/{appId}:exchangeCustomToken";
    var ONE_TIME_USE_TOKEN_VERIFICATION_URL_FORMAT = "https://firebaseappcheck.googleapis.com/v1beta/projects/{projectId}:verifyAppCheckToken";
    var FIREBASE_APP_CHECK_CONFIG_HEADERS = {
      "X-Firebase-Client": `fire-admin-node/${utils.getSdkVersion()}`
    };
    var AppCheckApiClient = class {
      constructor(app) {
        this.app = app;
        if (!validator.isNonNullObject(app) || !("options" in app)) {
          throw new FirebaseAppCheckError("invalid-argument", "First argument passed to admin.appCheck() must be a valid Firebase app instance.");
        }
        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
      }
      /**
       * Exchange a signed custom token to App Check token
       *
       * @param customToken - The custom token to be exchanged.
       * @param appId - The mobile App ID.
       * @returns A promise that fulfills with a `AppCheckToken`.
       */
      exchangeToken(customToken, appId) {
        if (!validator.isNonEmptyString(appId)) {
          throw new FirebaseAppCheckError("invalid-argument", "`appId` must be a non-empty string.");
        }
        if (!validator.isNonEmptyString(customToken)) {
          throw new FirebaseAppCheckError("invalid-argument", "`customToken` must be a non-empty string.");
        }
        return this.getUrl(appId).then((url) => {
          const request = {
            method: "POST",
            url,
            headers: FIREBASE_APP_CHECK_CONFIG_HEADERS,
            data: { customToken }
          };
          return this.httpClient.send(request);
        }).then((resp) => {
          return this.toAppCheckToken(resp);
        }).catch((err) => {
          throw this.toFirebaseError(err);
        });
      }
      verifyReplayProtection(token) {
        if (!validator.isNonEmptyString(token)) {
          throw new FirebaseAppCheckError("invalid-argument", "`token` must be a non-empty string.");
        }
        return this.getVerifyTokenUrl().then((url) => {
          const request = {
            method: "POST",
            url,
            headers: FIREBASE_APP_CHECK_CONFIG_HEADERS,
            data: { app_check_token: token }
          };
          return this.httpClient.send(request);
        }).then((resp) => {
          var _a;
          if (typeof resp.data.alreadyConsumed !== "undefined" && !validator.isBoolean((_a = resp.data) == null ? void 0 : _a.alreadyConsumed)) {
            throw new FirebaseAppCheckError("invalid-argument", "`alreadyConsumed` must be a boolean value.");
          }
          return resp.data.alreadyConsumed || false;
        }).catch((err) => {
          throw this.toFirebaseError(err);
        });
      }
      getUrl(appId) {
        return this.getProjectId().then((projectId) => {
          const urlParams = {
            projectId,
            appId
          };
          const baseUrl = utils.formatString(FIREBASE_APP_CHECK_V1_API_URL_FORMAT, urlParams);
          return utils.formatString(baseUrl);
        });
      }
      getVerifyTokenUrl() {
        return this.getProjectId().then((projectId) => {
          const urlParams = {
            projectId
          };
          const baseUrl = utils.formatString(ONE_TIME_USE_TOKEN_VERIFICATION_URL_FORMAT, urlParams);
          return utils.formatString(baseUrl);
        });
      }
      getProjectId() {
        if (this.projectId) {
          return Promise.resolve(this.projectId);
        }
        return utils.findProjectId(this.app).then((projectId) => {
          if (!validator.isNonEmptyString(projectId)) {
            throw new FirebaseAppCheckError("unknown-error", "Failed to determine project ID. Initialize the SDK with service account credentials or set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT environment variable.");
          }
          this.projectId = projectId;
          return projectId;
        });
      }
      toFirebaseError(err) {
        if (err instanceof error_1.PrefixedFirebaseError) {
          return err;
        }
        const response = err.response;
        if (!response.isJson()) {
          return new FirebaseAppCheckError("unknown-error", `Unexpected response with status: ${response.status} and body: ${response.text}`);
        }
        const error = response.data.error || {};
        let code = "unknown-error";
        if (error.status && error.status in exports.APP_CHECK_ERROR_CODE_MAPPING) {
          code = exports.APP_CHECK_ERROR_CODE_MAPPING[error.status];
        }
        const message = error.message || `Unknown server error: ${response.text}`;
        return new FirebaseAppCheckError(code, message);
      }
      /**
       * Creates an AppCheckToken from the API response.
       *
       * @param resp - API response object.
       * @returns An AppCheckToken instance.
       */
      toAppCheckToken(resp) {
        const token = resp.data.token;
        const ttlMillis = this.stringToMilliseconds(resp.data.ttl);
        return {
          token,
          ttlMillis
        };
      }
      /**
       * Converts a duration string with the suffix `s` to milliseconds.
       *
       * @param duration - The duration as a string with the suffix "s" preceded by the
       * number of seconds, with fractional seconds. For example, 3 seconds with 0 nanoseconds
       * is expressed as "3s", while 3 seconds and 1 nanosecond is expressed as "3.000000001s",
       * and 3 seconds and 1 microsecond is expressed as "3.000001s".
       *
       * @returns The duration in milliseconds.
       */
      stringToMilliseconds(duration) {
        if (!validator.isNonEmptyString(duration) || !duration.endsWith("s")) {
          throw new FirebaseAppCheckError("invalid-argument", "`ttl` must be a valid duration string with the suffix `s`.");
        }
        const seconds = duration.slice(0, -1);
        return Math.floor(Number(seconds) * 1e3);
      }
    };
    exports.AppCheckApiClient = AppCheckApiClient;
    exports.APP_CHECK_ERROR_CODE_MAPPING = {
      ABORTED: "aborted",
      INVALID_ARGUMENT: "invalid-argument",
      INVALID_CREDENTIAL: "invalid-credential",
      INTERNAL: "internal-error",
      PERMISSION_DENIED: "permission-denied",
      UNAUTHENTICATED: "unauthenticated",
      NOT_FOUND: "not-found",
      UNKNOWN: "unknown-error"
    };
    var FirebaseAppCheckError = class _FirebaseAppCheckError extends error_1.PrefixedFirebaseError {
      constructor(code, message) {
        super("app-check", code, message);
        this.__proto__ = _FirebaseAppCheckError.prototype;
      }
    };
    exports.FirebaseAppCheckError = FirebaseAppCheckError;
  }
});

// node_modules/firebase-admin/lib/app-check/token-generator.js
var require_token_generator = __commonJS({
  "node_modules/firebase-admin/lib/app-check/token-generator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.appCheckErrorFromCryptoSignerError = exports.AppCheckTokenGenerator = void 0;
    var validator = require_validator();
    var utils_1 = require_utils();
    var crypto_signer_1 = require_crypto_signer();
    var app_check_api_client_internal_1 = require_app_check_api_client_internal();
    var ONE_MINUTE_IN_SECONDS = 60;
    var ONE_MINUTE_IN_MILLIS = ONE_MINUTE_IN_SECONDS * 1e3;
    var ONE_DAY_IN_MILLIS = 24 * 60 * 60 * 1e3;
    var FIREBASE_APP_CHECK_AUDIENCE = "https://firebaseappcheck.googleapis.com/google.firebase.appcheck.v1.TokenExchangeService";
    var AppCheckTokenGenerator = class {
      /**
       * The AppCheckTokenGenerator class constructor.
       *
       * @param signer - The CryptoSigner instance for this token generator.
       * @constructor
       */
      constructor(signer) {
        if (!validator.isNonNullObject(signer)) {
          throw new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", "INTERNAL ASSERT: Must provide a CryptoSigner to use AppCheckTokenGenerator.");
        }
        this.signer = signer;
      }
      /**
       * Creates a new custom token that can be exchanged to an App Check token.
       *
       * @param appId - The Application ID to use for the generated token.
       *
       * @returns A Promise fulfilled with a custom token signed with a service account key
       * that can be exchanged to an App Check token.
       */
      createCustomToken(appId, options) {
        if (!validator.isNonEmptyString(appId)) {
          throw new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", "`appId` must be a non-empty string.");
        }
        let customOptions = {};
        if (typeof options !== "undefined") {
          customOptions = this.validateTokenOptions(options);
        }
        return this.signer.getAccountId().then((account) => {
          const header = {
            alg: this.signer.algorithm,
            typ: "JWT"
          };
          const iat = Math.floor(Date.now() / 1e3);
          const body = {
            iss: account,
            sub: account,
            app_id: appId,
            aud: FIREBASE_APP_CHECK_AUDIENCE,
            exp: iat + ONE_MINUTE_IN_SECONDS * 5,
            iat,
            ...customOptions
          };
          const token = `${this.encodeSegment(header)}.${this.encodeSegment(body)}`;
          return this.signer.sign(Buffer.from(token)).then((signature) => {
            return `${token}.${this.encodeSegment(signature)}`;
          });
        }).catch((err) => {
          throw appCheckErrorFromCryptoSignerError(err);
        });
      }
      encodeSegment(segment) {
        const buffer = segment instanceof Buffer ? segment : Buffer.from(JSON.stringify(segment));
        return (0, utils_1.toWebSafeBase64)(buffer).replace(/=+$/, "");
      }
      /**
       * Checks if a given `AppCheckTokenOptions` object is valid. If successful, returns an object with
       * custom properties.
       *
       * @param options - An options object to be validated.
       * @returns A custom object with ttl converted to protobuf Duration string format.
       */
      validateTokenOptions(options) {
        if (!validator.isNonNullObject(options)) {
          throw new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", "AppCheckTokenOptions must be a non-null object.");
        }
        if (typeof options.ttlMillis !== "undefined") {
          if (!validator.isNumber(options.ttlMillis)) {
            throw new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", "ttlMillis must be a duration in milliseconds.");
          }
          if (options.ttlMillis < ONE_MINUTE_IN_MILLIS * 30 || options.ttlMillis > ONE_DAY_IN_MILLIS * 7) {
            throw new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", "ttlMillis must be a duration in milliseconds between 30 minutes and 7 days (inclusive).");
          }
          return { ttl: (0, utils_1.transformMillisecondsToSecondsString)(options.ttlMillis) };
        }
        return {};
      }
    };
    exports.AppCheckTokenGenerator = AppCheckTokenGenerator;
    function appCheckErrorFromCryptoSignerError(err) {
      if (!(err instanceof crypto_signer_1.CryptoSignerError)) {
        return err;
      }
      if (err.code === crypto_signer_1.CryptoSignerErrorCode.SERVER_ERROR && validator.isNonNullObject(err.cause)) {
        const httpError = err.cause;
        const errorResponse = httpError.response.data;
        if (errorResponse == null ? void 0 : errorResponse.error) {
          const status = errorResponse.error.status;
          const description = errorResponse.error.message || JSON.stringify(httpError.response);
          let code = "unknown-error";
          if (status && status in app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING) {
            code = app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING[status];
          }
          return new app_check_api_client_internal_1.FirebaseAppCheckError(code, `Error returned from server while signing a custom token: ${description}`);
        }
        return new app_check_api_client_internal_1.FirebaseAppCheckError("internal-error", "Error returned from server: " + JSON.stringify(errorResponse) + ".");
      }
      return new app_check_api_client_internal_1.FirebaseAppCheckError(mapToAppCheckErrorCode(err.code), err.message);
    }
    exports.appCheckErrorFromCryptoSignerError = appCheckErrorFromCryptoSignerError;
    function mapToAppCheckErrorCode(code) {
      switch (code) {
        case crypto_signer_1.CryptoSignerErrorCode.INVALID_CREDENTIAL:
          return "invalid-credential";
        case crypto_signer_1.CryptoSignerErrorCode.INVALID_ARGUMENT:
          return "invalid-argument";
        default:
          return "internal-error";
      }
    }
  }
});

// node_modules/firebase-admin/lib/app-check/token-verifier.js
var require_token_verifier = __commonJS({
  "node_modules/firebase-admin/lib/app-check/token-verifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AppCheckTokenVerifier = void 0;
    var validator = require_validator();
    var util = require_utils();
    var app_check_api_client_internal_1 = require_app_check_api_client_internal();
    var jwt_1 = require_jwt();
    var APP_CHECK_ISSUER = "https://firebaseappcheck.googleapis.com/";
    var JWKS_URL = "https://firebaseappcheck.googleapis.com/v1/jwks";
    var AppCheckTokenVerifier = class {
      constructor(app) {
        this.app = app;
        this.signatureVerifier = jwt_1.PublicKeySignatureVerifier.withJwksUrl(JWKS_URL);
      }
      /**
       * Verifies the format and signature of a Firebase App Check token.
       *
       * @param token - The Firebase Auth JWT token to verify.
       * @returns A promise fulfilled with the decoded claims of the Firebase App Check token.
       */
      verifyToken(token) {
        if (!validator.isString(token)) {
          throw new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", "App check token must be a non-null string.");
        }
        return this.ensureProjectId().then((projectId) => {
          return this.decodeAndVerify(token, projectId);
        }).then((decoded) => {
          const decodedAppCheckToken = decoded.payload;
          decodedAppCheckToken.app_id = decodedAppCheckToken.sub;
          return decodedAppCheckToken;
        });
      }
      ensureProjectId() {
        return util.findProjectId(this.app).then((projectId) => {
          if (!validator.isNonEmptyString(projectId)) {
            throw new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-credential", "Must initialize app with a cert credential or set your Firebase project ID as the GOOGLE_CLOUD_PROJECT environment variable to verify an App Check token.");
          }
          return projectId;
        });
      }
      decodeAndVerify(token, projectId) {
        return this.safeDecode(token).then((decodedToken) => {
          this.verifyContent(decodedToken, projectId);
          return this.verifySignature(token).then(() => decodedToken);
        });
      }
      safeDecode(jwtToken) {
        return (0, jwt_1.decodeJwt)(jwtToken).catch(() => {
          const errorMessage = "Decoding App Check token failed. Make sure you passed the entire string JWT which represents the Firebase App Check token.";
          throw new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", errorMessage);
        });
      }
      /**
       * Verifies the content of a Firebase App Check JWT.
       *
       * @param fullDecodedToken - The decoded JWT.
       * @param projectId - The Firebase Project Id.
       */
      verifyContent(fullDecodedToken, projectId) {
        const header = fullDecodedToken.header;
        const payload = fullDecodedToken.payload;
        const projectIdMatchMessage = " Make sure the App Check token comes from the same Firebase project as the service account used to authenticate this SDK.";
        const scopedProjectId = `projects/${projectId}`;
        let errorMessage;
        if (header.alg !== jwt_1.ALGORITHM_RS256) {
          errorMessage = 'The provided App Check token has incorrect algorithm. Expected "' + jwt_1.ALGORITHM_RS256 + '" but got "' + header.alg + '".';
        } else if (!validator.isNonEmptyArray(payload.aud) || !payload.aud.includes(scopedProjectId)) {
          errorMessage = 'The provided App Check token has incorrect "aud" (audience) claim. Expected "' + scopedProjectId + '" but got "' + payload.aud + '".' + projectIdMatchMessage;
        } else if (typeof payload.iss !== "string" || !payload.iss.startsWith(APP_CHECK_ISSUER)) {
          errorMessage = 'The provided App Check token has incorrect "iss" (issuer) claim.';
        } else if (typeof payload.sub !== "string") {
          errorMessage = 'The provided App Check token has no "sub" (subject) claim.';
        } else if (payload.sub === "") {
          errorMessage = 'The provided App Check token has an empty string "sub" (subject) claim.';
        }
        if (errorMessage) {
          throw new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", errorMessage);
        }
      }
      verifySignature(jwtToken) {
        return this.signatureVerifier.verify(jwtToken).catch((error) => {
          throw this.mapJwtErrorToAppCheckError(error);
        });
      }
      /**
       * Maps JwtError to FirebaseAppCheckError
       *
       * @param error - JwtError to be mapped.
       * @returns FirebaseAppCheckError instance.
       */
      mapJwtErrorToAppCheckError(error) {
        if (error.code === jwt_1.JwtErrorCode.TOKEN_EXPIRED) {
          const errorMessage = "The provided App Check token has expired. Get a fresh App Check token from your client app and try again.";
          return new app_check_api_client_internal_1.FirebaseAppCheckError("app-check-token-expired", errorMessage);
        } else if (error.code === jwt_1.JwtErrorCode.INVALID_SIGNATURE) {
          const errorMessage = "The provided App Check token has invalid signature.";
          return new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", errorMessage);
        } else if (error.code === jwt_1.JwtErrorCode.NO_MATCHING_KID) {
          const errorMessage = 'The provided App Check token has "kid" claim which does not correspond to a known public key. Most likely the provided App Check token is expired, so get a fresh token from your client app and try again.';
          return new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", errorMessage);
        }
        return new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", error.message);
      }
    };
    exports.AppCheckTokenVerifier = AppCheckTokenVerifier;
  }
});

// node_modules/firebase-admin/lib/app-check/app-check.js
var require_app_check = __commonJS({
  "node_modules/firebase-admin/lib/app-check/app-check.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AppCheck = void 0;
    var validator = require_validator();
    var app_check_api_client_internal_1 = require_app_check_api_client_internal();
    var token_generator_1 = require_token_generator();
    var token_verifier_1 = require_token_verifier();
    var crypto_signer_1 = require_crypto_signer();
    var AppCheck = class {
      /**
       * @param app - The app for this AppCheck service.
       * @constructor
       * @internal
       */
      constructor(app) {
        this.app = app;
        this.client = new app_check_api_client_internal_1.AppCheckApiClient(app);
        try {
          this.tokenGenerator = new token_generator_1.AppCheckTokenGenerator((0, crypto_signer_1.cryptoSignerFromApp)(app));
        } catch (err) {
          throw (0, token_generator_1.appCheckErrorFromCryptoSignerError)(err);
        }
        this.appCheckTokenVerifier = new token_verifier_1.AppCheckTokenVerifier(app);
      }
      /**
       * Creates a new {@link AppCheckToken} that can be sent
       * back to a client.
       *
       * @param appId - The app ID to use as the JWT app_id.
       * @param options - Optional options object when creating a new App Check Token.
       *
       * @returns A promise that fulfills with a `AppCheckToken`.
       */
      createToken(appId, options) {
        return this.tokenGenerator.createCustomToken(appId, options).then((customToken) => {
          return this.client.exchangeToken(customToken, appId);
        });
      }
      /**
       * Verifies a Firebase App Check token (JWT). If the token is valid, the promise is
       * fulfilled with the token's decoded claims; otherwise, the promise is
       * rejected.
       *
       * @param appCheckToken - The App Check token to verify.
       * @param options - Optional {@link VerifyAppCheckTokenOptions} object when verifying an App Check Token.
       *
       * @returns A promise fulfilled with the token's decoded claims
       *   if the App Check token is valid; otherwise, a rejected promise.
       */
      verifyToken(appCheckToken, options) {
        this.validateVerifyAppCheckTokenOptions(options);
        return this.appCheckTokenVerifier.verifyToken(appCheckToken).then((decodedToken) => {
          if (options == null ? void 0 : options.consume) {
            return this.client.verifyReplayProtection(appCheckToken).then((alreadyConsumed) => {
              return {
                alreadyConsumed,
                appId: decodedToken.app_id,
                token: decodedToken
              };
            });
          }
          return {
            appId: decodedToken.app_id,
            token: decodedToken
          };
        });
      }
      validateVerifyAppCheckTokenOptions(options) {
        if (typeof options === "undefined") {
          return;
        }
        if (!validator.isNonNullObject(options)) {
          throw new app_check_api_client_internal_1.FirebaseAppCheckError("invalid-argument", "VerifyAppCheckTokenOptions must be a non-null object.");
        }
      }
    };
    exports.AppCheck = AppCheck;
  }
});

// node_modules/firebase-admin/lib/app-check/index.js
var require_app_check2 = __commonJS({
  "node_modules/firebase-admin/lib/app-check/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAppCheck = exports.AppCheck = void 0;
    var app_1 = require_app();
    var app_check_1 = require_app_check();
    var app_check_2 = require_app_check();
    Object.defineProperty(exports, "AppCheck", { enumerable: true, get: function() {
      return app_check_2.AppCheck;
    } });
    function getAppCheck(app) {
      if (typeof app === "undefined") {
        app = (0, app_1.getApp)();
      }
      const firebaseApp = app;
      return firebaseApp.getOrInitService("appCheck", (app2) => new app_check_1.AppCheck(app2));
    }
    exports.getAppCheck = getAppCheck;
  }
});

// node_modules/firebase-functions/lib/common/config.js
var require_config = __commonJS({
  "node_modules/firebase-functions/lib/common/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.firebaseConfig = exports.resetCache = void 0;
    var fs_1 = require_fs();
    var path = require_path();
    var logger = require_logger();
    var cache = null;
    function resetCache(newCache = null) {
      cache = newCache;
    }
    exports.resetCache = resetCache;
    function firebaseConfig() {
      if (cache) {
        return cache;
      }
      let env = process.env.FIREBASE_CONFIG;
      if (env) {
        if (!env.startsWith("{")) {
          env = (0, fs_1.readFileSync)(path.join(process.env.PWD, env)).toString("utf8");
        }
        cache = JSON.parse(env);
        return cache;
      }
      if (process.env.GCLOUD_PROJECT) {
        logger.warn("Warning, estimating Firebase Config based on GCLOUD_PROJECT. Initializing firebase-admin may fail");
        cache = {
          databaseURL: process.env.DATABASE_URL || `https://${process.env.GCLOUD_PROJECT}.firebaseio.com`,
          storageBucket: process.env.STORAGE_BUCKET_URL || `${process.env.GCLOUD_PROJECT}.appspot.com`,
          projectId: process.env.GCLOUD_PROJECT
        };
        return cache;
      } else {
        logger.warn("Warning, FIREBASE_CONFIG and GCLOUD_PROJECT environment variables are missing. Initializing firebase-admin will fail");
      }
      return null;
    }
    exports.firebaseConfig = firebaseConfig;
  }
});

// node_modules/firebase-functions/lib/common/app.js
var require_app2 = __commonJS({
  "node_modules/firebase-functions/lib/common/app.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setApp = exports.getApp = void 0;
    var app_1 = require_app();
    var config_1 = require_config();
    var APP_NAME = "__FIREBASE_FUNCTIONS_SDK__";
    var cache;
    function getApp() {
      if (typeof cache === "undefined") {
        try {
          cache = (0, app_1.getApp)(
            /* default */
          );
        } catch {
          cache = (0, app_1.initializeApp)({
            ...(0, config_1.firebaseConfig)(),
            credential: (0, app_1.applicationDefault)()
          }, APP_NAME);
        }
      }
      return cache;
    }
    exports.getApp = getApp;
    function setApp(app) {
      if ((cache === null || cache === void 0 ? void 0 : cache.name) === APP_NAME) {
        void (0, app_1.deleteApp)(cache);
      }
      cache = app;
    }
    exports.setApp = setApp;
  }
});

// node_modules/firebase-functions/lib/common/providers/https.js
var require_https = __commonJS({
  "node_modules/firebase-functions/lib/common/providers/https.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onCallHandler = exports.checkAuthToken = exports.unsafeDecodeAppCheckToken = exports.unsafeDecodeIdToken = exports.unsafeDecodeToken = exports.decode = exports.encode = exports.isValidRequest = exports.HttpsError = exports.ORIGINAL_AUTH_HEADER = exports.CALLABLE_AUTH_HEADER = void 0;
    var cors = require_lib();
    var logger = require_logger();
    var app_check_1 = require_app_check2();
    var auth_1 = require_auth();
    var app_1 = require_app2();
    var debug_1 = require_debug();
    var JWT_REGEX = /^[a-zA-Z0-9\-_=]+?\.[a-zA-Z0-9\-_=]+?\.([a-zA-Z0-9\-_=]+)?$/;
    exports.CALLABLE_AUTH_HEADER = "x-callable-context-auth";
    exports.ORIGINAL_AUTH_HEADER = "x-original-auth";
    var errorCodeMap = {
      ok: { canonicalName: "OK", status: 200 },
      cancelled: { canonicalName: "CANCELLED", status: 499 },
      unknown: { canonicalName: "UNKNOWN", status: 500 },
      "invalid-argument": { canonicalName: "INVALID_ARGUMENT", status: 400 },
      "deadline-exceeded": { canonicalName: "DEADLINE_EXCEEDED", status: 504 },
      "not-found": { canonicalName: "NOT_FOUND", status: 404 },
      "already-exists": { canonicalName: "ALREADY_EXISTS", status: 409 },
      "permission-denied": { canonicalName: "PERMISSION_DENIED", status: 403 },
      unauthenticated: { canonicalName: "UNAUTHENTICATED", status: 401 },
      "resource-exhausted": { canonicalName: "RESOURCE_EXHAUSTED", status: 429 },
      "failed-precondition": { canonicalName: "FAILED_PRECONDITION", status: 400 },
      aborted: { canonicalName: "ABORTED", status: 409 },
      "out-of-range": { canonicalName: "OUT_OF_RANGE", status: 400 },
      unimplemented: { canonicalName: "UNIMPLEMENTED", status: 501 },
      internal: { canonicalName: "INTERNAL", status: 500 },
      unavailable: { canonicalName: "UNAVAILABLE", status: 503 },
      "data-loss": { canonicalName: "DATA_LOSS", status: 500 }
    };
    var HttpsError = class extends Error {
      constructor(code, message, details) {
        super(message);
        if (code in errorCodeMap === false) {
          throw new Error(`Unknown error code: ${code}.`);
        }
        this.code = code;
        this.details = details;
        this.httpErrorCode = errorCodeMap[code];
      }
      /**
       * Returns a JSON-serializable representation of this object.
       */
      toJSON() {
        const { details, httpErrorCode: { canonicalName: status }, message } = this;
        return {
          ...details === void 0 ? {} : { details },
          message,
          status
        };
      }
    };
    exports.HttpsError = HttpsError;
    function isValidRequest(req) {
      if (!req.body) {
        logger.warn("Request is missing body.");
        return false;
      }
      if (req.method !== "POST") {
        logger.warn("Request has invalid method.", req.method);
        return false;
      }
      let contentType = (req.header("Content-Type") || "").toLowerCase();
      const semiColon = contentType.indexOf(";");
      if (semiColon >= 0) {
        contentType = contentType.slice(0, semiColon).trim();
      }
      if (contentType !== "application/json") {
        logger.warn("Request has incorrect Content-Type.", contentType);
        return false;
      }
      if (typeof req.body.data === "undefined") {
        logger.warn("Request body is missing data.", req.body);
        return false;
      }
      const extraKeys = Object.keys(req.body).filter((field) => field !== "data");
      if (extraKeys.length !== 0) {
        logger.warn("Request body has extra fields: ", extraKeys.join(", "));
        return false;
      }
      return true;
    }
    exports.isValidRequest = isValidRequest;
    var LONG_TYPE = "type.googleapis.com/google.protobuf.Int64Value";
    var UNSIGNED_LONG_TYPE = "type.googleapis.com/google.protobuf.UInt64Value";
    function encode(data) {
      if (data === null || typeof data === "undefined") {
        return null;
      }
      if (data instanceof Number) {
        data = data.valueOf();
      }
      if (Number.isFinite(data)) {
        return data;
      }
      if (typeof data === "boolean") {
        return data;
      }
      if (typeof data === "string") {
        return data;
      }
      if (Array.isArray(data)) {
        return data.map(encode);
      }
      if (typeof data === "object" || typeof data === "function") {
        const obj = {};
        for (const [k, v] of Object.entries(data)) {
          obj[k] = encode(v);
        }
        return obj;
      }
      logger.error("Data cannot be encoded in JSON.", data);
      throw new Error(`Data cannot be encoded in JSON: ${data}`);
    }
    exports.encode = encode;
    function decode(data) {
      if (data === null) {
        return data;
      }
      if (data["@type"]) {
        switch (data["@type"]) {
          case LONG_TYPE:
          case UNSIGNED_LONG_TYPE: {
            const value = parseFloat(data.value);
            if (isNaN(value)) {
              logger.error("Data cannot be decoded from JSON.", data);
              throw new Error(`Data cannot be decoded from JSON: ${data}`);
            }
            return value;
          }
          default: {
            logger.error("Data cannot be decoded from JSON.", data);
            throw new Error(`Data cannot be decoded from JSON: ${data}`);
          }
        }
      }
      if (Array.isArray(data)) {
        return data.map(decode);
      }
      if (typeof data === "object") {
        const obj = {};
        for (const [k, v] of Object.entries(data)) {
          obj[k] = decode(v);
        }
        return obj;
      }
      return data;
    }
    exports.decode = decode;
    function unsafeDecodeToken(token) {
      if (!JWT_REGEX.test(token)) {
        return {};
      }
      const components = token.split(".").map((s) => Buffer.from(s, "base64").toString());
      let payload = components[1];
      if (typeof payload === "string") {
        try {
          const obj = JSON.parse(payload);
          if (typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      return payload;
    }
    exports.unsafeDecodeToken = unsafeDecodeToken;
    function unsafeDecodeIdToken(token) {
      const decoded = unsafeDecodeToken(token);
      decoded.uid = decoded.sub;
      return decoded;
    }
    exports.unsafeDecodeIdToken = unsafeDecodeIdToken;
    function unsafeDecodeAppCheckToken(token) {
      const decoded = unsafeDecodeToken(token);
      decoded.app_id = decoded.sub;
      return decoded;
    }
    exports.unsafeDecodeAppCheckToken = unsafeDecodeAppCheckToken;
    async function checkTokens(req, ctx, options) {
      const verifications = {
        app: "INVALID",
        auth: "INVALID"
      };
      await Promise.all([
        Promise.resolve().then(async () => {
          verifications.auth = await checkAuthToken(req, ctx);
        }),
        Promise.resolve().then(async () => {
          verifications.app = await checkAppCheckToken(req, ctx, options);
        })
      ]);
      const logPayload = {
        verifications,
        "logging.googleapis.com/labels": {
          "firebase-log-type": "callable-request-verification"
        }
      };
      const errs = [];
      if (verifications.app === "INVALID") {
        errs.push("AppCheck token was rejected.");
      }
      if (verifications.auth === "INVALID") {
        errs.push("Auth token was rejected.");
      }
      if (errs.length === 0) {
        logger.debug("Callable request verification passed", logPayload);
      } else {
        logger.warn(`Callable request verification failed: ${errs.join(" ")}`, logPayload);
      }
      return verifications;
    }
    async function checkAuthToken(req, ctx) {
      const authorization = req.header("Authorization");
      if (!authorization) {
        return "MISSING";
      }
      const match = authorization.match(/^Bearer (.*)$/i);
      if (!match) {
        return "INVALID";
      }
      const idToken = match[1];
      try {
        let authToken;
        if ((0, debug_1.isDebugFeatureEnabled)("skipTokenVerification")) {
          authToken = unsafeDecodeIdToken(idToken);
        } else {
          authToken = await (0, auth_1.getAuth)((0, app_1.getApp)()).verifyIdToken(idToken);
        }
        ctx.auth = {
          uid: authToken.uid,
          token: authToken
        };
        return "VALID";
      } catch (err) {
        logger.warn("Failed to validate auth token.", err);
        return "INVALID";
      }
    }
    exports.checkAuthToken = checkAuthToken;
    async function checkAppCheckToken(req, ctx, options) {
      var _a;
      const appCheckToken = req.header("X-Firebase-AppCheck");
      if (!appCheckToken) {
        return "MISSING";
      }
      try {
        let appCheckData;
        if ((0, debug_1.isDebugFeatureEnabled)("skipTokenVerification")) {
          const decodedToken = unsafeDecodeAppCheckToken(appCheckToken);
          appCheckData = { appId: decodedToken.app_id, token: decodedToken };
          if (options.consumeAppCheckToken) {
            appCheckData.alreadyConsumed = false;
          }
        } else {
          const appCheck = (0, app_check_1.getAppCheck)((0, app_1.getApp)());
          if (options.consumeAppCheckToken) {
            if (((_a = appCheck.verifyToken) === null || _a === void 0 ? void 0 : _a.length) === 1) {
              const errorMsg = "Unsupported version of the Admin SDK. App Check token will not be consumed. Please upgrade the firebase-admin to the latest version.";
              logger.error(errorMsg);
              throw new HttpsError("internal", "Internal Error");
            }
            appCheckData = await (0, app_check_1.getAppCheck)((0, app_1.getApp)()).verifyToken(appCheckToken, { consume: true });
          } else {
            appCheckData = await (0, app_check_1.getAppCheck)((0, app_1.getApp)()).verifyToken(appCheckToken);
          }
        }
        ctx.app = appCheckData;
        return "VALID";
      } catch (err) {
        logger.warn("Failed to validate AppCheck token.", err);
        if (err instanceof HttpsError) {
          throw err;
        }
        return "INVALID";
      }
    }
    function onCallHandler(options, handler) {
      const wrapped = wrapOnCallHandler(options, handler);
      return (req, res) => {
        return new Promise((resolve) => {
          res.on("finish", resolve);
          cors(options.cors)(req, res, () => {
            resolve(wrapped(req, res));
          });
        });
      };
    }
    exports.onCallHandler = onCallHandler;
    function wrapOnCallHandler(options, handler) {
      return async (req, res) => {
        try {
          if (!isValidRequest(req)) {
            logger.error("Invalid request, unable to process.");
            throw new HttpsError("invalid-argument", "Bad Request");
          }
          const context = { rawRequest: req };
          if ((0, debug_1.isDebugFeatureEnabled)("skipTokenVerification") && handler.length === 2) {
            const authContext = context.rawRequest.header(exports.CALLABLE_AUTH_HEADER);
            if (authContext) {
              logger.debug("Callable functions auth override", {
                key: exports.CALLABLE_AUTH_HEADER,
                value: authContext
              });
              context.auth = JSON.parse(decodeURIComponent(authContext));
              delete context.rawRequest.headers[exports.CALLABLE_AUTH_HEADER];
            }
            const originalAuth = context.rawRequest.header(exports.ORIGINAL_AUTH_HEADER);
            if (originalAuth) {
              context.rawRequest.headers["authorization"] = originalAuth;
              delete context.rawRequest.headers[exports.ORIGINAL_AUTH_HEADER];
            }
          }
          const tokenStatus = await checkTokens(req, context, options);
          if (tokenStatus.auth === "INVALID") {
            throw new HttpsError("unauthenticated", "Unauthenticated");
          }
          if (tokenStatus.app === "INVALID") {
            if (options.enforceAppCheck) {
              throw new HttpsError("unauthenticated", "Unauthenticated");
            } else {
              logger.warn("Allowing request with invalid AppCheck token because enforcement is disabled");
            }
          }
          if (tokenStatus.app === "MISSING" && options.enforceAppCheck) {
            throw new HttpsError("unauthenticated", "Unauthenticated");
          }
          const instanceId = req.header("Firebase-Instance-ID-Token");
          if (instanceId) {
            context.instanceIdToken = req.header("Firebase-Instance-ID-Token");
          }
          const data = decode(req.body.data);
          let result;
          if (handler.length === 2) {
            result = await handler(data, context);
          } else {
            const arg = {
              ...context,
              data
            };
            result = await handler(arg);
          }
          result = encode(result);
          const responseBody = { result };
          res.status(200).send(responseBody);
        } catch (err) {
          let httpErr = err;
          if (!(err instanceof HttpsError)) {
            logger.error("Unhandled error", err);
            httpErr = new HttpsError("internal", "INTERNAL");
          }
          const { status } = httpErr.httpErrorCode;
          const body = { error: httpErr.toJSON() };
          res.status(status).send(body);
        }
      };
    }
  }
});

// node_modules/firebase-functions/lib/common/options.js
var require_options = __commonJS({
  "node_modules/firebase-functions/lib/common/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RESET_VALUE = exports.ResetValue = void 0;
    var ResetValue = class _ResetValue {
      toJSON() {
        return null;
      }
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      constructor() {
      }
      static getInstance() {
        return new _ResetValue();
      }
    };
    exports.ResetValue = ResetValue;
    exports.RESET_VALUE = ResetValue.getInstance();
  }
});

// node_modules/firebase-functions/lib/runtime/manifest.js
var require_manifest = __commonJS({
  "node_modules/firebase-functions/lib/runtime/manifest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initV2ScheduleTrigger = exports.initV1ScheduleTrigger = exports.initTaskQueueTrigger = exports.initV2Endpoint = exports.initV1Endpoint = exports.stackToWire = void 0;
    var options_1 = require_options();
    var params_1 = require_params();
    function stackToWire(stack) {
      const wireStack = stack;
      const traverse = function traverse2(obj) {
        for (const [key, val] of Object.entries(obj)) {
          if (val instanceof params_1.Expression) {
            obj[key] = val.toCEL();
          } else if (val instanceof options_1.ResetValue) {
            obj[key] = val.toJSON();
          } else if (typeof val === "object" && val !== null) {
            traverse2(val);
          }
        }
      };
      traverse(wireStack.endpoints);
      return wireStack;
    }
    exports.stackToWire = stackToWire;
    var RESETTABLE_OPTIONS = {
      availableMemoryMb: null,
      timeoutSeconds: null,
      minInstances: null,
      maxInstances: null,
      ingressSettings: null,
      concurrency: null,
      serviceAccountEmail: null,
      vpc: null
    };
    function initEndpoint(resetOptions, ...opts) {
      const endpoint = {};
      if (opts.every((opt) => !(opt === null || opt === void 0 ? void 0 : opt.preserveExternalChanges))) {
        for (const key of Object.keys(resetOptions)) {
          endpoint[key] = options_1.RESET_VALUE;
        }
      }
      return endpoint;
    }
    function initV1Endpoint(...opts) {
      const { concurrency, ...resetOpts } = RESETTABLE_OPTIONS;
      return initEndpoint({ ...resetOpts }, ...opts);
    }
    exports.initV1Endpoint = initV1Endpoint;
    function initV2Endpoint(...opts) {
      return initEndpoint(RESETTABLE_OPTIONS, ...opts);
    }
    exports.initV2Endpoint = initV2Endpoint;
    var RESETTABLE_RETRY_CONFIG_OPTIONS = {
      maxAttempts: null,
      maxDoublings: null,
      maxBackoffSeconds: null,
      maxRetrySeconds: null,
      minBackoffSeconds: null
    };
    var RESETTABLE_RATE_LIMITS_OPTIONS = {
      maxConcurrentDispatches: null,
      maxDispatchesPerSecond: null
    };
    function initTaskQueueTrigger(...opts) {
      const taskQueueTrigger = {
        retryConfig: {},
        rateLimits: {}
      };
      if (opts.every((opt) => !(opt === null || opt === void 0 ? void 0 : opt.preserveExternalChanges))) {
        for (const key of Object.keys(RESETTABLE_RETRY_CONFIG_OPTIONS)) {
          taskQueueTrigger.retryConfig[key] = options_1.RESET_VALUE;
        }
        for (const key of Object.keys(RESETTABLE_RATE_LIMITS_OPTIONS)) {
          taskQueueTrigger.rateLimits[key] = options_1.RESET_VALUE;
        }
      }
      return taskQueueTrigger;
    }
    exports.initTaskQueueTrigger = initTaskQueueTrigger;
    var RESETTABLE_V1_SCHEDULE_OPTIONS = {
      retryCount: null,
      maxDoublings: null,
      maxRetryDuration: null,
      maxBackoffDuration: null,
      minBackoffDuration: null
    };
    var RESETTABLE_V2_SCHEDULE_OPTIONS = {
      retryCount: null,
      maxDoublings: null,
      maxRetrySeconds: null,
      minBackoffSeconds: null,
      maxBackoffSeconds: null
    };
    function initScheduleTrigger(resetOptions, schedule, ...opts) {
      let scheduleTrigger = {
        schedule,
        retryConfig: {}
      };
      if (opts.every((opt) => !(opt === null || opt === void 0 ? void 0 : opt.preserveExternalChanges))) {
        for (const key of Object.keys(resetOptions)) {
          scheduleTrigger.retryConfig[key] = options_1.RESET_VALUE;
        }
        scheduleTrigger = { ...scheduleTrigger, timeZone: options_1.RESET_VALUE };
      }
      return scheduleTrigger;
    }
    function initV1ScheduleTrigger(schedule, ...opts) {
      return initScheduleTrigger(RESETTABLE_V1_SCHEDULE_OPTIONS, schedule, ...opts);
    }
    exports.initV1ScheduleTrigger = initV1ScheduleTrigger;
    function initV2ScheduleTrigger(schedule, ...opts) {
      return initScheduleTrigger(RESETTABLE_V2_SCHEDULE_OPTIONS, schedule, ...opts);
    }
    exports.initV2ScheduleTrigger = initV2ScheduleTrigger;
  }
});

// node_modules/firebase-functions/lib/v2/options.js
var require_options2 = __commonJS({
  "node_modules/firebase-functions/lib/v2/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__getSpec = exports.optionsToEndpoint = exports.optionsToTriggerAnnotations = exports.getGlobalOptions = exports.setGlobalOptions = exports.RESET_VALUE = void 0;
    var encoding_1 = require_encoding();
    var options_1 = require_options();
    var params_1 = require_params();
    var types_1 = require_types();
    var logger = require_logger();
    var options_2 = require_options();
    Object.defineProperty(exports, "RESET_VALUE", { enumerable: true, get: function() {
      return options_2.RESET_VALUE;
    } });
    var MemoryOptionToMB = {
      "128MiB": 128,
      "256MiB": 256,
      "512MiB": 512,
      "1GiB": 1024,
      "2GiB": 2048,
      "4GiB": 4096,
      "8GiB": 8192,
      "16GiB": 16384,
      "32GiB": 32768
    };
    var globalOptions;
    function setGlobalOptions(options) {
      if (globalOptions) {
        logger.warn("Calling setGlobalOptions twice leads to undefined behavior");
      }
      globalOptions = options;
    }
    exports.setGlobalOptions = setGlobalOptions;
    function getGlobalOptions() {
      return globalOptions || {};
    }
    exports.getGlobalOptions = getGlobalOptions;
    function optionsToTriggerAnnotations(opts) {
      const annotation = {};
      (0, encoding_1.copyIfPresent)(annotation, opts, "concurrency", "minInstances", "maxInstances", "ingressSettings", "labels", "vpcConnector", "vpcConnectorEgressSettings", "secrets");
      (0, encoding_1.convertIfPresent)(annotation, opts, "availableMemoryMb", "memory", (mem) => {
        return MemoryOptionToMB[mem];
      });
      (0, encoding_1.convertIfPresent)(annotation, opts, "regions", "region", (region) => {
        if (typeof region === "string") {
          return [region];
        }
        return region;
      });
      (0, encoding_1.convertIfPresent)(annotation, opts, "serviceAccountEmail", "serviceAccount", encoding_1.serviceAccountFromShorthand);
      (0, encoding_1.convertIfPresent)(annotation, opts, "timeout", "timeoutSeconds", encoding_1.durationFromSeconds);
      (0, encoding_1.convertIfPresent)(annotation, opts, "failurePolicy", "retry", (retry) => {
        return retry ? { retry: true } : null;
      });
      return annotation;
    }
    exports.optionsToTriggerAnnotations = optionsToTriggerAnnotations;
    function optionsToEndpoint(opts) {
      const endpoint = {};
      (0, encoding_1.copyIfPresent)(endpoint, opts, "omit", "concurrency", "minInstances", "maxInstances", "ingressSettings", "labels", "timeoutSeconds", "cpu");
      (0, encoding_1.convertIfPresent)(endpoint, opts, "serviceAccountEmail", "serviceAccount");
      if (opts.vpcConnector !== void 0) {
        if (opts.vpcConnector === null || opts.vpcConnector instanceof options_1.ResetValue) {
          endpoint.vpc = options_1.RESET_VALUE;
        } else {
          const vpc = { connector: opts.vpcConnector };
          (0, encoding_1.convertIfPresent)(vpc, opts, "egressSettings", "vpcConnectorEgressSettings");
          endpoint.vpc = vpc;
        }
      }
      (0, encoding_1.convertIfPresent)(endpoint, opts, "availableMemoryMb", "memory", (mem) => {
        return typeof mem === "object" ? mem : MemoryOptionToMB[mem];
      });
      (0, encoding_1.convertIfPresent)(endpoint, opts, "region", "region", (region) => {
        if (typeof region === "string") {
          return [region];
        }
        return region;
      });
      (0, encoding_1.convertIfPresent)(endpoint, opts, "secretEnvironmentVariables", "secrets", (secrets) => secrets.map((secret) => ({ key: secret instanceof types_1.SecretParam ? secret.name : secret })));
      return endpoint;
    }
    exports.optionsToEndpoint = optionsToEndpoint;
    function __getSpec() {
      return {
        globalOptions: getGlobalOptions(),
        params: params_1.declaredParams.map((p) => p.toSpec())
      };
    }
    exports.__getSpec = __getSpec;
  }
});

// node_modules/firebase-functions/lib/v2/providers/https.js
var require_https2 = __commonJS({
  "node_modules/firebase-functions/lib/v2/providers/https.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onCall = exports.onRequest = exports.HttpsError = void 0;
    var cors = require_lib();
    var encoding_1 = require_encoding();
    var trace_1 = require_trace2();
    var debug_1 = require_debug();
    var https_1 = require_https();
    Object.defineProperty(exports, "HttpsError", { enumerable: true, get: function() {
      return https_1.HttpsError;
    } });
    var manifest_1 = require_manifest();
    var options = require_options2();
    function onRequest(optsOrHandler, handler) {
      let opts;
      if (arguments.length === 1) {
        opts = {};
        handler = optsOrHandler;
      } else {
        opts = optsOrHandler;
      }
      if ((0, debug_1.isDebugFeatureEnabled)("enableCors") || "cors" in opts) {
        let origin = opts.cors;
        if ((0, debug_1.isDebugFeatureEnabled)("enableCors")) {
          origin = opts.cors === false ? false : true;
        }
        const userProvidedHandler = handler;
        handler = (req, res) => {
          return new Promise((resolve) => {
            res.on("finish", resolve);
            cors({ origin })(req, res, () => {
              resolve(userProvidedHandler(req, res));
            });
          });
        };
      }
      handler = (0, trace_1.wrapTraceContext)(handler);
      Object.defineProperty(handler, "__trigger", {
        get: () => {
          const baseOpts2 = options.optionsToTriggerAnnotations(options.getGlobalOptions());
          const specificOpts2 = options.optionsToTriggerAnnotations(opts);
          const trigger = {
            platform: "gcfv2",
            ...baseOpts2,
            ...specificOpts2,
            labels: {
              ...baseOpts2 === null || baseOpts2 === void 0 ? void 0 : baseOpts2.labels,
              ...specificOpts2 === null || specificOpts2 === void 0 ? void 0 : specificOpts2.labels
            },
            httpsTrigger: {
              allowInsecure: false
            }
          };
          (0, encoding_1.convertIfPresent)(trigger.httpsTrigger, opts, "invoker", "invoker", encoding_1.convertInvoker);
          return trigger;
        }
      });
      const baseOpts = options.optionsToEndpoint(options.getGlobalOptions());
      const specificOpts = options.optionsToEndpoint(opts);
      const endpoint = {
        ...(0, manifest_1.initV2Endpoint)(options.getGlobalOptions(), opts),
        platform: "gcfv2",
        ...baseOpts,
        ...specificOpts,
        labels: {
          ...baseOpts === null || baseOpts === void 0 ? void 0 : baseOpts.labels,
          ...specificOpts === null || specificOpts === void 0 ? void 0 : specificOpts.labels
        },
        httpsTrigger: {}
      };
      (0, encoding_1.convertIfPresent)(endpoint.httpsTrigger, opts, "invoker", "invoker", encoding_1.convertInvoker);
      handler.__endpoint = endpoint;
      return handler;
    }
    exports.onRequest = onRequest;
    function onCall(optsOrHandler, handler) {
      var _a;
      let opts;
      if (arguments.length === 1) {
        opts = {};
        handler = optsOrHandler;
      } else {
        opts = optsOrHandler;
      }
      const origin = (0, debug_1.isDebugFeatureEnabled)("enableCors") ? true : "cors" in opts ? opts.cors : true;
      const fixedLen = (req) => handler(req);
      const func = (0, https_1.onCallHandler)({
        cors: { origin, methods: "POST" },
        enforceAppCheck: (_a = opts.enforceAppCheck) !== null && _a !== void 0 ? _a : options.getGlobalOptions().enforceAppCheck,
        consumeAppCheckToken: opts.consumeAppCheckToken
      }, fixedLen);
      Object.defineProperty(func, "__trigger", {
        get: () => {
          const baseOpts2 = options.optionsToTriggerAnnotations(options.getGlobalOptions());
          const specificOpts2 = options.optionsToTriggerAnnotations(opts);
          return {
            platform: "gcfv2",
            ...baseOpts2,
            ...specificOpts2,
            labels: {
              ...baseOpts2 === null || baseOpts2 === void 0 ? void 0 : baseOpts2.labels,
              ...specificOpts2 === null || specificOpts2 === void 0 ? void 0 : specificOpts2.labels,
              "deployment-callable": "true"
            },
            httpsTrigger: {
              allowInsecure: false
            }
          };
        }
      });
      const baseOpts = options.optionsToEndpoint(options.getGlobalOptions());
      const specificOpts = options.optionsToEndpoint(opts);
      func.__endpoint = {
        ...(0, manifest_1.initV2Endpoint)(options.getGlobalOptions(), opts),
        platform: "gcfv2",
        ...baseOpts,
        ...specificOpts,
        labels: {
          ...baseOpts === null || baseOpts === void 0 ? void 0 : baseOpts.labels,
          ...specificOpts === null || specificOpts === void 0 ? void 0 : specificOpts.labels
        },
        callableTrigger: {}
      };
      func.run = handler;
      return func;
    }
    exports.onCall = onCall;
  }
});
export default require_https2();
/*! Bundled license information:

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

vary/index.js:
  (*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

firebase-admin/lib/app-check/app-check-api-client-internal.js:
  (*! firebase-admin v11.10.1 *)
  (*!
   * @license
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/app-check/token-generator.js:
  (*! firebase-admin v11.10.1 *)
  (*!
   * @license
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/app-check/token-verifier.js:
  (*! firebase-admin v11.10.1 *)
  (*!
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/app-check/app-check.js:
  (*! firebase-admin v11.10.1 *)
  (*!
   * @license
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/app-check/index.js:
  (*! firebase-admin v11.10.1 *)
  (*!
   * @license
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=firebase-functions_v2_https.js.map
